import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
import express from "express";
import { createServer } from "./mcp-server.js";
import { logger } from "./utils/logger.js";
import bodyParser from "body-parser";
import cors from "cors";

// Default configuration
const API_URL = process.env.EREGULATIONS_API_URL || "https://api-tanzania.tradeportal.org";
const PORT = parseInt(process.env.PORT || '7000', 10);
const SSE_PATH = '/sse';
const MESSAGE_PATH = '/message';
const ENABLE_CORS = process.env.DISABLE_CORS !== 'true';

// Create server and Express app
const { server, cleanup } = createServer(API_URL);
const app = express();

// Session storage as a simple record
const sessions: Record<string, { transport: SSEServerTransport; response: express.Response }> = {};

logger.info('Starting eRegulations MCP server...');
logger.info(`  - port: ${PORT}`);
logger.info(`  - API URL: ${API_URL}`);
logger.info(`  - ssePath: ${SSE_PATH}`);
logger.info(`  - messagePath: ${MESSAGE_PATH}`);
logger.info(`  - CORS enabled: ${ENABLE_CORS}`);

// Set up signal handlers
const onSignals = () => {
  ['SIGINT', 'SIGTERM', 'SIGHUP'].forEach(signal => {
    process.on(signal, () => {
      logger.info(`${signal} received. Exiting...`);
      // Clean up all sessions
      for (const sessionId of Object.keys(sessions)) {
        try {
          delete sessions[sessionId];
        } catch (err) {
          logger.error(`Error cleaning up session ${sessionId}:`, err);
        }
      }
      cleanup();
      process.exit(0);
    });
  });

  process.stdin.on('close', () => {
    logger.info('stdin closed. Exiting...');
    cleanup();
    process.exit(0);
  });
};

// Initialize signal handlers
onSignals();

// Set up Express middleware
if (ENABLE_CORS) {
  app.use(cors());
}

app.use((req, res, next) => {
  if (req.path === MESSAGE_PATH) return next();
  return bodyParser.json()(req, res, next);
});

// SSE endpoint
app.get(SSE_PATH, async (req, res) => {
  logger.info(`New SSE connection from ${req.ip}`);

  // Set SSE headers
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache, no-transform');
  res.setHeader('Connection', 'keep-alive');

  try {
    // Create transport with the message path
    const transportPath = MESSAGE_PATH;
    const sseTransport = new SSEServerTransport(transportPath, res);
    
    // Connect the server to this transport
    await server.connect(sseTransport);

    // Get session ID from transport and store session
    const sessionId = sseTransport.sessionId;
    if (sessionId) {
      // Store session
      sessions[sessionId] = { transport: sseTransport, response: res };
      logger.info(`Session established: ${sessionId}`);

      // Set up heartbeat
      const heartbeat = setInterval(() => {
        try {
          res.write(": heartbeat\n\n");
        } catch (err) {
          logger.error(`Heartbeat failed for session ${sessionId}:`, err);
          clearInterval(heartbeat);
          delete sessions[sessionId];
        }
      }, 30000);

      // Clean up on close
      res.on('close', () => {
        clearInterval(heartbeat);
      });

      // Set up transport event handlers
      sseTransport.onmessage = (msg) => {
        logger.info(`Message from client (session ${sessionId}): ${JSON.stringify(msg)}`);
      };

      sseTransport.onclose = () => {
        logger.info(`SSE connection closed (session ${sessionId})`);
        delete sessions[sessionId];
      };

      sseTransport.onerror = (err) => {
        logger.error(`SSE error (session ${sessionId}):`, err);
        delete sessions[sessionId];
      };

      // Handle client disconnect
      req.on('close', () => {
        logger.info(`Client disconnected (session ${sessionId})`);
        delete sessions[sessionId];
      });

      // Send initialization message to client
      res.write(`data: ${JSON.stringify({ sessionId, status: "connected" })}\n\n`);
    } else {
      logger.error('No session ID generated by SSE transport');
      res.status(500).send('Failed to create session');
    }
  } catch (error) {
    logger.error(`Error setting up SSE transport:`, error);
    if (!res.headersSent) {
      res.status(500).send(`Error setting up SSE transport: ${error instanceof Error ? error.message : String(error)}`);
    } else {
      try {
        res.write(`data: ${JSON.stringify({ error: "Connection error", message: String(error) })}\n\n`);
        res.end();
      } catch (writeError) {
        logger.error(`Failed to write error to response:`, writeError);
      }
    }
  }
});

// Message endpoint for client to post messages to the server
app.post(MESSAGE_PATH, async (req, res) => {
  const sessionId = req.query.sessionId as string;
  if (!sessionId) {
    logger.warn("Missing sessionId parameter");
    return res.status(400).send('Missing sessionId parameter');
  }

  const session = sessions[sessionId];
  if (session?.transport?.handlePostMessage) {
    logger.info(`POST to SSE transport (session ${sessionId})`);
    try {
      await session.transport.handlePostMessage(req, res);
    } catch (error) {
      logger.error(`Error handling message for session ${sessionId}:`, error);
      if (!res.headersSent) {
        res.status(500).send(`Error handling message: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  } else {
    logger.warn(`No active SSE connection for session ${sessionId}`);
    res.status(503).send(`No active SSE connection for session ${sessionId}`);
  }
});

// Start the server
const httpServer = app.listen(PORT, () => {
  logger.info(`eRegulations MCP server running on port ${PORT}`);
  logger.info(`SSE endpoint: http://localhost:${PORT}${SSE_PATH}`);
  logger.info(`POST messages: http://localhost:${PORT}${MESSAGE_PATH}`);
});

// Graceful shutdown handling for the HTTP server
httpServer.on('close', () => {
  logger.info('HTTP server closed.');
  cleanup();
});